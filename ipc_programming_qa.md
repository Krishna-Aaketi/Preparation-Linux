## Inter-Process Communication (IPC) â€“ Interview Questions and Answers

### Pipes

**1. What is a pipe in Linux?**\
A pipe is a unidirectional communication channel used for inter-process communication (IPC).

**2. How do you create a pipe in C?**

```c
int fd[2];
pipe(fd); // fd[0] is read end, fd[1] is write end
```

**3. What is the difference between anonymous and named pipes?**\
Anonymous pipes exist only during the lifetime of the process. Named pipes (FIFOs) persist in the filesystem.

**4. How do you create a named pipe?**\
Using `mkfifo()`:

```c
mkfifo("myfifo", 0666);
```

**5. Can pipes be used for communication between unrelated processes?**\
Anonymous pipes require a parent-child relationship. Named pipes can be used between unrelated processes.

### Message Queues

**6. What is a message queue?**\
A message queue is a data structure used to exchange messages between processes using message identifiers.

**7. How to create or get a message queue ID?**

```c
int msgid = msgget(key, IPC_CREAT | 0666);
```

**8. How do you send a message?**

```c
struct msgbuf {
  long mtype;
  char mtext[100];
};
msgsnd(msgid, &msg, sizeof(msg.mtext), 0);
```

**9. How do you receive a message?**

```c
msgrcv(msgid, &msg, sizeof(msg.mtext), mtype, 0);
```

**10. How to delete a message queue?**

```c
msgctl(msgid, IPC_RMID, NULL);
```

### Shared Memory

**11. What is shared memory?**\
A segment of memory that can be simultaneously accessed by multiple processes.

**12. How to create a shared memory segment?**

```c
int shmid = shmget(key, size, IPC_CREAT | 0666);
```

**13. How to attach shared memory to a process?**

```c
void* ptr = shmat(shmid, NULL, 0);
```

**14. How to detach shared memory?**

```c
shmdt(ptr);
```

**15. How to delete shared memory?**

```c
shmctl(shmid, IPC_RMID, NULL);
```

### Semaphores

**16. What is a semaphore?**\
A semaphore is a synchronization tool used to control access to a shared resource.

**17. How to create a semaphore set?**

```c
int semid = semget(key, num_sems, IPC_CREAT | 0666);
```

**18. How to perform semaphore operations (P/V)?**

```c
struct sembuf op = {0, -1, 0};
semop(semid, &op, 1); // wait (P operation)

op.sem_op = 1;
semop(semid, &op, 1); // signal (V operation)
```

**19. How to delete a semaphore?**

```c
semctl(semid, 0, IPC_RMID);
```

**20. What is the difference between binary and counting semaphores?**\
Binary semaphores only have 0 or 1 value. Counting semaphores can have a range of values.

### Sockets

**21. What is a socket?**\
A socket is an endpoint for communication between two machines or processes.

**22. What are AF\_UNIX and AF\_INET?**

- AF\_UNIX: Used for local IPC.
- AF\_INET: Used for network communication using IP.

**23. How to create a socket?**

```c
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
```

**24. What are the different types of sockets?**

- SOCK\_STREAM: TCP
- SOCK\_DGRAM: UDP

**25. What is bind()?** Assigns an address to the socket.

**26. What is listen() and accept()?**

- `listen()`: Marks socket as passive to accept incoming connections.
- `accept()`: Accepts a connection from a client.

**27. What is connect()?** Used by a client to establish a connection to a server socket.

**28. How does socket communication differ from pipes?** Sockets can be used for both local and remote communication. Pipes are limited to local IPC.

**29. How to send and receive data using sockets?**

```c
send(sockfd, buffer, size, 0);
recv(sockfd, buffer, size, 0);
```

**30. How to close a socket?**

```c
close(sockfd);
```

### General IPC Concepts

**31. What is IPC?**\
Inter-Process Communication refers to mechanisms that allow processes to communicate and synchronize.

**32. How does IPC differ from signals?** Signals are event notifications. IPC allows data transfer.

**33. When would you prefer shared memory over pipes?** For high-speed and large-volume data transfer.

**34. What are synchronization issues in IPC?** Race conditions, deadlocks, and inconsistent data access.

**35. How to avoid race conditions in shared memory?** Use semaphores or mutexes.

**36. Can IPC occur between different users?** Yes, depending on permissions set during resource creation.

**37. What is IPC\_PRIVATE?** A special key indicating that a new resource should be created and not shared via a key.

**38. What happens if a process crashes and leaves shared memory?** It can be cleaned using `ipcrm` or by deleting it programmatically.

**39. How are IPC resources identified?** Via keys and IDs generated by `ftok()` and returned by `shmget()`, `msgget()`, etc.

**40. What is the purpose of **``**?** Generates a unique key for IPC mechanisms based on a filename and a project ID.

**41. Can you combine multiple IPC mechanisms?** Yes, for example, use shared memory with semaphores for synchronization.

**42. What is the default buffer size of a pipe?** Typically 64 KB, but can vary by system.

**43. Can pipes be non-blocking?** Yes, using `fcntl()` to set O\_NONBLOCK flag.

**44. What is the purpose of **``** in sockets?** Monitors multiple file descriptors to see if I/O is possible.

**45. What is socketpair()?** Creates a pair of connected sockets for local communication.

**46. What are domain sockets?** Local IPC sockets using `AF_UNIX` instead of IP addresses.

**47. What is netlink socket?** A socket family used for communication between kernel and user-space.

**48. What happens if shared memory is not detached?** Memory stays allocated and may lead to leaks or stale data.

**49. What are the limits on message queues?** Defined by system parameters like `msgmax` (max size per message).

**50. How do you debug IPC resources?** Using tools like `ipcs`, `lsof`, `strace`, and `netstat`.

